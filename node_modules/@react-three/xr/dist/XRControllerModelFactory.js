"use strict";
Object.defineProperties(exports, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
const THREE = require("three");
const threeStdlib = require("three-stdlib");
const DEFAULT_PROFILES_PATH = "https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles";
const DEFAULT_PROFILE = "generic-trigger";
const applyEnvironmentMap = (envMap, obj) => {
  obj.traverse((child) => {
    if (child instanceof THREE.Mesh && "envMap" in child.material) {
      child.material.envMap = envMap;
      child.material.needsUpdate = true;
    }
  });
};
class XRControllerModel extends THREE.Object3D {
  constructor() {
    super();
    this.motionController = null;
    this.envMap = null;
    this.scene = null;
  }
  setEnvironmentMap(envMap) {
    if (this.envMap == envMap) {
      return this;
    }
    this.envMap = envMap;
    applyEnvironmentMap(this.envMap, this);
    return this;
  }
  connectModel(scene) {
    if (!this.motionController) {
      console.warn("scene tried to add, but no motion controller");
      return;
    }
    this.scene = scene;
    addAssetSceneToControllerModel(this, scene);
    this.dispatchEvent({
      type: "modelconnected",
      data: scene
    });
  }
  connectMotionController(motionController) {
    this.motionController = motionController;
    this.dispatchEvent({
      type: "motionconnected",
      data: motionController
    });
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    if (!this.motionController)
      return;
    this.motionController.updateFromGamepad();
    Object.values(this.motionController.components).forEach((component) => {
      Object.values(component.visualResponses).forEach((visualResponse) => {
        const { valueNode, minNode, maxNode, value, valueNodeProperty } = visualResponse;
        if (!valueNode)
          return;
        if (valueNodeProperty === threeStdlib.MotionControllerConstants.VisualResponseProperty.VISIBILITY && typeof value === "boolean") {
          valueNode.visible = value;
        } else if (valueNodeProperty === threeStdlib.MotionControllerConstants.VisualResponseProperty.TRANSFORM && minNode && maxNode && typeof value === "number") {
          valueNode.quaternion.slerpQuaternions(minNode.quaternion, maxNode.quaternion, value);
          valueNode.position.lerpVectors(minNode.position, maxNode.position, value);
        }
      });
    });
  }
  disconnect() {
    this.dispatchEvent({
      type: "motiondisconnected",
      data: this.motionController
    });
    this.dispatchEvent({
      type: "modeldisconnected",
      data: this.scene
    });
    this.motionController = null;
    if (this.scene) {
      this.remove(this.scene);
    }
    this.scene = null;
  }
  dispose() {
    this.disconnect();
  }
}
function findNodes(motionController, scene) {
  Object.values(motionController.components).forEach((component) => {
    const { type, touchPointNodeName, visualResponses } = component;
    if (type === threeStdlib.MotionControllerConstants.ComponentType.TOUCHPAD && touchPointNodeName) {
      component.touchPointNode = scene.getObjectByName(touchPointNodeName);
      if (component.touchPointNode) {
        const sphereGeometry = new THREE.SphereGeometry(1e-3);
        const material = new THREE.MeshBasicMaterial({ color: 255 });
        const sphere = new THREE.Mesh(sphereGeometry, material);
        component.touchPointNode.add(sphere);
      } else {
        console.warn(`Could not find touch dot, ${component.touchPointNodeName}, in touchpad component ${component.id}`);
      }
    }
    Object.values(visualResponses).forEach((visualResponse) => {
      const { valueNodeName, minNodeName, maxNodeName, valueNodeProperty } = visualResponse;
      if (valueNodeProperty === threeStdlib.MotionControllerConstants.VisualResponseProperty.TRANSFORM && minNodeName && maxNodeName) {
        visualResponse.minNode = scene.getObjectByName(minNodeName);
        visualResponse.maxNode = scene.getObjectByName(maxNodeName);
        if (!visualResponse.minNode) {
          console.warn(`Could not find ${minNodeName} in the model`);
          return;
        }
        if (!visualResponse.maxNode) {
          console.warn(`Could not find ${maxNodeName} in the model`);
          return;
        }
      }
      visualResponse.valueNode = scene.getObjectByName(valueNodeName);
      if (!visualResponse.valueNode) {
        console.warn(`Could not find ${valueNodeName} in the model`);
      }
    });
  });
}
function addAssetSceneToControllerModel(controllerModel, scene) {
  findNodes(controllerModel.motionController, scene);
  if (controllerModel.envMap) {
    applyEnvironmentMap(controllerModel.envMap, scene);
  }
  controllerModel.add(scene);
}
class XRControllerModelFactory {
  constructor(gltfLoader = null, path = DEFAULT_PROFILES_PATH) {
    this.gltfLoader = gltfLoader != null ? gltfLoader : new threeStdlib.GLTFLoader();
    this.path = path;
    this._assetCache = {};
  }
  initializeControllerModel(controllerModel, event) {
    const xrInputSource = event.data;
    if (xrInputSource.targetRayMode !== "tracked-pointer" || !xrInputSource.gamepad)
      return;
    threeStdlib.fetchProfile(xrInputSource, this.path, DEFAULT_PROFILE).then(({ profile, assetPath }) => {
      if (!assetPath) {
        throw new Error("no asset path");
      }
      const motionController = new threeStdlib.MotionController(xrInputSource, profile, assetPath);
      controllerModel.connectMotionController(motionController);
      const assetUrl = motionController.assetUrl;
      const cachedAsset = this._assetCache[assetUrl];
      if (cachedAsset) {
        const scene = cachedAsset.scene.clone();
        controllerModel.connectModel(scene);
      } else {
        if (!this.gltfLoader) {
          throw new Error("GLTFLoader not set.");
        }
        this.gltfLoader.setPath("");
        this.gltfLoader.load(
          assetUrl,
          (asset) => {
            if (!controllerModel.motionController) {
              console.warn("motionController gone while gltf load, bailing...");
              return;
            }
            this._assetCache[assetUrl] = asset;
            const scene = asset.scene.clone();
            controllerModel.connectModel(scene);
          },
          void 0,
          () => {
            throw new Error(`Asset ${assetUrl} missing or malformed.`);
          }
        );
      }
    }).catch((err) => {
      console.warn(err);
    });
  }
}
exports.XRControllerModel = XRControllerModel;
exports.XRControllerModelFactory = XRControllerModelFactory;
//# sourceMappingURL=XRControllerModelFactory.js.map
