import {
  GLTFLoader,
  MotionController,
  MotionControllerConstants,
  OculusHandModel,
  fetchProfile
} from "./chunk-X27MR5JJ.js";
import {
  BufferGeometry,
  Group,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  Object3D,
  SphereGeometry,
  Vector3,
  createPortal,
  extend,
  useFrame,
  useThree
} from "./chunk-PELYWEJX.js";
import {
  create
} from "./chunk-NJUEDCQ7.js";
import {
  __toESM,
  require_react
} from "./chunk-VWEV35CT.js";

// node_modules/@react-three/xr/dist/Controllers.mjs
var React4 = __toESM(require_react(), 1);

// node_modules/@react-three/xr/dist/XR.mjs
var React3 = __toESM(require_react(), 1);

// node_modules/@react-three/xr/dist/XRController.mjs
var XRController = class extends Group {
  constructor(index, gl) {
    super();
    this.index = index;
    this.controller = gl.xr.getController(index);
    this.grip = gl.xr.getControllerGrip(index);
    this.hand = gl.xr.getHand(index);
    this.grip.userData.name = "grip";
    this.controller.userData.name = "controller";
    this.hand.userData.name = "hand";
    this.visible = false;
    this.add(this.controller, this.grip, this.hand);
    this._onConnected = this._onConnected.bind(this);
    this._onDisconnected = this._onDisconnected.bind(this);
    this.controller.addEventListener("connected", this._onConnected);
    this.controller.addEventListener("disconnected", this._onDisconnected);
  }
  _onConnected(event) {
    if (event.fake)
      return;
    this.visible = true;
    this.inputSource = event.data;
    this.dispatchEvent(event);
  }
  _onDisconnected(event) {
    if (event.fake)
      return;
    this.visible = false;
    this.dispatchEvent(event);
  }
  dispose() {
    this.controller.removeEventListener("connected", this._onConnected);
    this.controller.removeEventListener("disconnected", this._onDisconnected);
  }
};

// node_modules/@react-three/xr/dist/Interactions.mjs
var React2 = __toESM(require_react(), 1);

// node_modules/@react-three/xr/dist/utils.mjs
var React = __toESM(require_react(), 1);
var _a;
var _b;
var uniq = (arr) => Array.from(new Set(arr));
var useIsomorphicLayoutEffect = typeof window !== "undefined" && (((_a = window.document) == null ? void 0 : _a.createElement) || ((_b = window.navigator) == null ? void 0 : _b.product) === "ReactNative") ? React.useLayoutEffect : React.useEffect;
function useCallbackRef(fn) {
  const ref = React.useRef(fn);
  useIsomorphicLayoutEffect(() => void (ref.current = fn), [fn]);
  return ref;
}

// node_modules/@react-three/xr/dist/XREvents.mjs
function useXREvent(event, handler, { handedness } = {}) {
  const handlerRef = useCallbackRef(handler);
  const controllers = useXR((state) => state.controllers);
  useIsomorphicLayoutEffect(() => {
    const listeners = controllers.map((target) => {
      if (handedness && target.inputSource.handedness !== handedness)
        return;
      const listener = (nativeEvent) => handlerRef.current({ nativeEvent, target });
      target.controller.addEventListener(event, listener);
      return () => target.controller.removeEventListener(event, listener);
    });
    return () => listeners.forEach((cleanup) => cleanup == null ? void 0 : cleanup());
  }, [controllers, handedness, event]);
}

// node_modules/@react-three/xr/dist/Interactions.mjs
var tempMatrix = new Matrix4();
function InteractionManager({ children }) {
  const events = useThree((state) => state.events);
  const get = useThree((state) => state.get);
  const raycaster = useThree((state) => state.raycaster);
  const controllers = useXR((state) => state.controllers);
  const interactions = useXR((state) => state.interactions);
  const hoverState = useXR((state) => state.hoverState);
  const hasInteraction = useXR((state) => state.hasInteraction);
  const getInteraction = useXR((state) => state.getInteraction);
  const intersect = React2.useCallback(
    (controller) => {
      const objects = Array.from(interactions.keys());
      tempMatrix.identity().extractRotation(controller.matrixWorld);
      raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
      raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
      return raycaster.intersectObjects(objects, true);
    },
    [interactions, raycaster]
  );
  useFrame(() => {
    if (interactions.size === 0)
      return;
    for (const target of controllers) {
      const hovering = hoverState[target.inputSource.handedness];
      const hits = /* @__PURE__ */ new Set();
      let intersections = intersect(target.controller);
      if (events.filter) {
        intersections = events.filter(intersections, get());
      } else {
        const hit = intersections.find((i) => i == null ? void 0 : i.object);
        if (hit)
          intersections = [hit];
      }
      for (const intersection of intersections) {
        let eventObject = intersection.object;
        while (eventObject) {
          if (hasInteraction(eventObject, "onHover") && !hovering.has(eventObject)) {
            const handlers = getInteraction(eventObject, "onHover");
            for (const handler of handlers) {
              handler({ target, intersection, intersections });
            }
          }
          const moveHandlers = getInteraction(eventObject, "onMove");
          moveHandlers == null ? void 0 : moveHandlers.forEach((handler) => handler({ target, intersection, intersections }));
          hovering.set(eventObject, intersection);
          hits.add(eventObject.id);
          eventObject = eventObject.parent;
        }
      }
      for (const eventObject of hovering.keys()) {
        if (!hits.has(eventObject.id)) {
          hovering.delete(eventObject);
          const handlers = getInteraction(eventObject, "onBlur");
          if (!handlers)
            continue;
          for (const handler of handlers) {
            handler({ target, intersections });
          }
        }
      }
    }
  });
  const triggerEvent = React2.useCallback(
    (interaction) => (e) => {
      const hovering = hoverState[e.target.inputSource.handedness];
      const intersections = Array.from(new Set(hovering.values()));
      interactions.forEach((handlers, object) => {
        var _a2, _b2, _c;
        if (hovering.has(object)) {
          if (!handlers[interaction])
            return;
          for (const handler of handlers[interaction]) {
            (_a2 = handler.current) == null ? void 0 : _a2.call(handler, { target: e.target, intersection: hovering.get(object), intersections });
          }
        } else {
          if (interaction === "onSelect" && handlers["onSelectMissed"]) {
            for (const handler of handlers["onSelectMissed"]) {
              (_b2 = handler.current) == null ? void 0 : _b2.call(handler, { target: e.target, intersections });
            }
          } else if (interaction === "onSqueeze" && handlers["onSqueezeMissed"]) {
            for (const handler of handlers["onSqueezeMissed"]) {
              (_c = handler.current) == null ? void 0 : _c.call(handler, { target: e.target, intersections });
            }
          }
        }
      });
    },
    [hoverState, interactions]
  );
  useXREvent("select", triggerEvent("onSelect"));
  useXREvent("selectstart", triggerEvent("onSelectStart"));
  useXREvent("selectend", triggerEvent("onSelectEnd"));
  useXREvent("squeeze", triggerEvent("onSqueeze"));
  useXREvent("squeezeend", triggerEvent("onSqueezeEnd"));
  useXREvent("squeezestart", triggerEvent("onSqueezeStart"));
  return React2.createElement(React2.Fragment, null, children);
}
function useInteraction(ref, type, handler) {
  const addInteraction = useXR((state) => state.addInteraction);
  const removeInteraction = useXR((state) => state.removeInteraction);
  const handlerRef = useCallbackRef(handler);
  useIsomorphicLayoutEffect(() => {
    const target = ref.current;
    if (!target || !handlerRef.current)
      return;
    addInteraction(target, type, handlerRef);
    return () => removeInteraction(target, type, handlerRef);
  }, [ref, type, addInteraction, removeInteraction]);
}
var Interactive = React2.forwardRef(function Interactive2({
  onHover,
  onBlur,
  onSelectStart,
  onSelectEnd,
  onSelectMissed,
  onSelect,
  onSqueezeStart,
  onSqueezeEnd,
  onSqueezeMissed,
  onSqueeze,
  onMove,
  children
}, passedRef) {
  const ref = React2.useRef(null);
  React2.useImperativeHandle(passedRef, () => ref.current);
  useInteraction(ref, "onHover", onHover);
  useInteraction(ref, "onBlur", onBlur);
  useInteraction(ref, "onSelectStart", onSelectStart);
  useInteraction(ref, "onSelectEnd", onSelectEnd);
  useInteraction(ref, "onSelectMissed", onSelectMissed);
  useInteraction(ref, "onSelect", onSelect);
  useInteraction(ref, "onSqueezeStart", onSqueezeStart);
  useInteraction(ref, "onSqueezeEnd", onSqueezeEnd);
  useInteraction(ref, "onSqueezeMissed", onSqueezeMissed);
  useInteraction(ref, "onSqueeze", onSqueeze);
  useInteraction(ref, "onMove", onMove);
  return React2.createElement("group", {
    ref
  }, children);
});
var RayGrab = React2.forwardRef(function RayGrab2({ onSelectStart, onSelectEnd, children, ...rest }, forwardedRef) {
  const grabbingController = React2.useRef();
  const groupRef = React2.useRef(null);
  const previousTransform = React2.useMemo(() => new Matrix4(), []);
  React2.useImperativeHandle(forwardedRef, () => groupRef.current);
  useFrame(() => {
    const controller = grabbingController.current;
    const group = groupRef.current;
    if (!controller)
      return;
    group.applyMatrix4(previousTransform);
    group.applyMatrix4(controller.matrixWorld);
    group.updateMatrixWorld();
    previousTransform.copy(controller.matrixWorld).invert();
  });
  return React2.createElement(Interactive, {
    ref: groupRef,
    onSelectStart: (e) => {
      grabbingController.current = e.target.controller;
      previousTransform.copy(e.target.controller.matrixWorld).invert();
      onSelectStart == null ? void 0 : onSelectStart(e);
    },
    onSelectEnd: (e) => {
      if (e.target.controller === grabbingController.current) {
        grabbingController.current = void 0;
      }
      onSelectEnd == null ? void 0 : onSelectEnd(e);
    },
    ...rest
  }, children);
});
function useHitTest(hitTestCallback) {
  const session = useXR((state) => state.session);
  const hitTestSource = React2.useRef();
  const hitMatrix = React2.useMemo(() => new Matrix4(), []);
  useIsomorphicLayoutEffect(() => {
    if (!session)
      return void (hitTestSource.current = void 0);
    session.requestReferenceSpace("viewer").then(async (referenceSpace) => {
      var _a2;
      hitTestSource.current = await ((_a2 = session == null ? void 0 : session.requestHitTestSource) == null ? void 0 : _a2.call(session, { space: referenceSpace }));
    });
  }, [session]);
  useFrame((state, _, frame) => {
    if (!frame || !hitTestSource.current)
      return;
    const [hit] = frame.getHitTestResults(hitTestSource.current);
    if (hit) {
      const referenceSpace = state.gl.xr.getReferenceSpace();
      const pose = hit.getPose(referenceSpace);
      if (pose) {
        hitMatrix.fromArray(pose.transform.matrix);
        hitTestCallback(hitMatrix, hit);
      }
    }
  });
}

// node_modules/@react-three/xr/dist/XR.mjs
var XRContext = React3.createContext(null);
var globalSessionStore = create((set, get) => ({ set, get, session: null, referenceSpaceType: null }));
function XRManager({
  foveation = 0,
  referenceSpace = "local-floor",
  onSessionStart,
  onSessionEnd,
  onVisibilityChange,
  onInputSourcesChange,
  children
}) {
  const gl = useThree((state) => state.gl);
  const camera = useThree((state) => state.camera);
  const player = useXR((state) => state.player);
  const get = useXR((state) => state.get);
  const set = useXR((state) => state.set);
  const session = useXR((state) => state.session);
  const controllers = useXR((state) => state.controllers);
  const onSessionStartRef = useCallbackRef(onSessionStart);
  const onSessionEndRef = useCallbackRef(onSessionEnd);
  const onVisibilityChangeRef = useCallbackRef(onVisibilityChange);
  const onInputSourcesChangeRef = useCallbackRef(onInputSourcesChange);
  useIsomorphicLayoutEffect(() => {
    const handlers = [0, 1].map((id) => {
      const target = new XRController(id, gl);
      const onConnected = () => set((state) => ({ controllers: [...state.controllers, target] }));
      const onDisconnected = () => set((state) => ({ controllers: state.controllers.filter((it) => it !== target) }));
      target.addEventListener("connected", onConnected);
      target.addEventListener("disconnected", onDisconnected);
      return () => {
        target.removeEventListener("connected", onConnected);
        target.removeEventListener("disconnected", onDisconnected);
      };
    });
    return () => handlers.forEach((cleanup) => cleanup());
  }, [gl, set]);
  useIsomorphicLayoutEffect(() => globalSessionStore.subscribe(({ session: session2 }) => set(() => ({ session: session2 }))), [gl.xr, set]);
  useIsomorphicLayoutEffect(() => {
    gl.xr.setFoveation(foveation);
    set(() => ({ foveation }));
  }, [gl.xr, foveation, set]);
  useIsomorphicLayoutEffect(() => {
    const globalSessionState = globalSessionStore.getState();
    gl.xr.setReferenceSpaceType(referenceSpace);
    set(() => ({ referenceSpace }));
    globalSessionState.set({ referenceSpaceType: referenceSpace });
  }, [gl.xr, referenceSpace, set]);
  useIsomorphicLayoutEffect(() => {
    if (!session)
      return void gl.xr.setSession(null);
    const handleSessionStart = (nativeEvent) => {
      var _a2;
      set(() => ({ isPresenting: true }));
      (_a2 = onSessionStartRef.current) == null ? void 0 : _a2.call(onSessionStartRef, { nativeEvent: { ...nativeEvent, target: session }, target: session });
    };
    const handleSessionEnd = (nativeEvent) => {
      var _a2;
      set(() => ({ isPresenting: false, session: null }));
      globalSessionStore.setState(() => ({ session: null }));
      (_a2 = onSessionEndRef.current) == null ? void 0 : _a2.call(onSessionEndRef, { nativeEvent: { ...nativeEvent, target: session }, target: session });
    };
    const handleVisibilityChange = (nativeEvent) => {
      var _a2;
      (_a2 = onVisibilityChangeRef.current) == null ? void 0 : _a2.call(onVisibilityChangeRef, { nativeEvent, target: session });
    };
    const handleInputSourcesChange = (nativeEvent) => {
      var _a2;
      const isHandTracking = Object.values(session.inputSources).some((source) => source.hand);
      set(() => ({ isHandTracking }));
      (_a2 = onInputSourcesChangeRef.current) == null ? void 0 : _a2.call(onInputSourcesChangeRef, { nativeEvent, target: session });
    };
    gl.xr.addEventListener("sessionstart", handleSessionStart);
    gl.xr.addEventListener("sessionend", handleSessionEnd);
    session.addEventListener("visibilitychange", handleVisibilityChange);
    session.addEventListener("inputsourceschange", handleInputSourcesChange);
    gl.xr.setSession(session).then(() => {
      gl.xr.setFoveation(get().foveation);
    });
    return () => {
      gl.xr.removeEventListener("sessionstart", handleSessionStart);
      gl.xr.removeEventListener("sessionend", handleSessionEnd);
      session.removeEventListener("visibilitychange", handleVisibilityChange);
      session.removeEventListener("inputsourceschange", handleInputSourcesChange);
    };
  }, [session, gl.xr, set, get]);
  return React3.createElement(InteractionManager, null, React3.createElement("primitive", {
    object: player
  }, React3.createElement("primitive", {
    object: camera
  }), controllers.map((controller) => React3.createElement("primitive", {
    key: controller.index,
    object: controller
  }))), children);
}
function XR(props) {
  const store = React3.useMemo(
    () => create((set, get) => ({
      set,
      get,
      controllers: [],
      isPresenting: false,
      isHandTracking: false,
      player: new Group(),
      session: null,
      foveation: 0,
      referenceSpace: "local-floor",
      hoverState: {
        left: /* @__PURE__ */ new Map(),
        right: /* @__PURE__ */ new Map(),
        none: /* @__PURE__ */ new Map()
      },
      interactions: /* @__PURE__ */ new Map(),
      hasInteraction(object, eventType) {
        var _a2;
        return !!((_a2 = get().interactions.get(object)) == null ? void 0 : _a2[eventType].some((handlerRef) => handlerRef.current));
      },
      getInteraction(object, eventType) {
        var _a2;
        return (_a2 = get().interactions.get(object)) == null ? void 0 : _a2[eventType].reduce((result, handlerRef) => {
          if (handlerRef.current) {
            result.push(handlerRef.current);
          }
          return result;
        }, []);
      },
      addInteraction(object, eventType, handlerRef) {
        const interactions = get().interactions;
        if (!interactions.has(object)) {
          interactions.set(object, {
            onHover: [],
            onBlur: [],
            onSelect: [],
            onSelectEnd: [],
            onSelectStart: [],
            onSelectMissed: [],
            onSqueeze: [],
            onSqueezeEnd: [],
            onSqueezeStart: [],
            onSqueezeMissed: [],
            onMove: []
          });
        }
        const target = interactions.get(object);
        target[eventType].push(handlerRef);
      },
      removeInteraction(object, eventType, handlerRef) {
        const target = get().interactions.get(object);
        if (target) {
          const interactionIndex = target[eventType].indexOf(handlerRef);
          if (interactionIndex !== -1)
            target[eventType].splice(interactionIndex, 1);
        }
      }
    })),
    []
  );
  return React3.createElement(XRContext.Provider, {
    value: store
  }, React3.createElement(XRManager, {
    ...props
  }));
}
var getSessionOptions = (globalStateReferenceSpaceType, sessionInit) => {
  var _a2;
  if (!globalStateReferenceSpaceType && !sessionInit) {
    return void 0;
  }
  if (globalStateReferenceSpaceType && !sessionInit) {
    return { optionalFeatures: [globalStateReferenceSpaceType] };
  }
  if (globalStateReferenceSpaceType && sessionInit) {
    return { ...sessionInit, optionalFeatures: uniq([...(_a2 = sessionInit.optionalFeatures) != null ? _a2 : [], globalStateReferenceSpaceType]) };
  }
  return sessionInit;
};
var startSession = async (sessionMode, sessionInit) => {
  const xrState = globalSessionStore.getState();
  if (xrState.session) {
    console.warn("@react-three/xr: session already started, please stop it first");
    return;
  }
  const options = getSessionOptions(xrState.referenceSpaceType, sessionInit);
  const session = await navigator.xr.requestSession(sessionMode, options);
  xrState.set(() => ({ session }));
  return session;
};
var stopSession = async () => {
  const xrState = globalSessionStore.getState();
  if (!xrState.session) {
    console.warn("@react-three/xr: no session to stop, please start it first");
    return;
  }
  await xrState.session.end();
  xrState.set({ session: null });
};
var toggleSession = async (sessionMode, { sessionInit, enterOnly, exitOnly } = {}) => {
  const xrState = globalSessionStore.getState();
  if (xrState.session && enterOnly)
    return;
  if (!xrState.session && exitOnly)
    return;
  if (xrState.session) {
    return await stopSession();
  } else {
    return await startSession(sessionMode, sessionInit);
  }
};
var XRButton = React3.forwardRef(function XRButton2({ mode, sessionInit, enterOnly = false, exitOnly = false, onClick, onError, children, ...props }, ref) {
  const [status, setStatus] = React3.useState("exited");
  const label = status === "unsupported" ? `${mode} unsupported` : `${status === "entered" ? "Exit" : "Enter"} ${mode}`;
  const sessionMode = mode === "inline" ? mode : `immersive-${mode.toLowerCase()}`;
  const onErrorRef = useCallbackRef(onError);
  useIsomorphicLayoutEffect(() => {
    if (!(navigator == null ? void 0 : navigator.xr))
      return void setStatus("unsupported");
    navigator.xr.isSessionSupported(sessionMode).then((supported) => setStatus(supported ? "exited" : "unsupported"));
  }, [sessionMode]);
  useIsomorphicLayoutEffect(
    () => globalSessionStore.subscribe((state) => {
      if (state.session) {
        setStatus("entered");
      } else if (status !== "unsupported") {
        setStatus("exited");
      }
    }),
    [status]
  );
  const handleButtonClick = React3.useCallback(
    async (event) => {
      onClick == null ? void 0 : onClick(event);
      try {
        toggleSession(sessionMode, { sessionInit, enterOnly, exitOnly });
      } catch (e) {
        const onError2 = onErrorRef.current;
        if (onError2 && e instanceof Error)
          onError2(e);
        else
          throw e;
      }
    },
    [onClick, sessionMode, sessionInit, enterOnly, exitOnly, onErrorRef]
  );
  return React3.createElement("button", {
    ...props,
    ref,
    onClick: status === "unsupported" ? onClick : handleButtonClick
  }, typeof children === "function" ? children(status) : children != null ? children : label);
});
var buttonStyles = {
  position: "absolute",
  bottom: "24px",
  left: "50%",
  transform: "translateX(-50%)",
  padding: "12px 24px",
  border: "1px solid white",
  borderRadius: "4px",
  background: "rgba(0, 0, 0, 0.1)",
  color: "white",
  font: "normal 0.8125rem sans-serif",
  outline: "none",
  zIndex: 99999,
  cursor: "pointer"
};
var ARButton = React3.forwardRef(
  ({
    style = buttonStyles,
    sessionInit = {
      domOverlay: typeof document !== "undefined" ? { root: document.body } : void 0,
      optionalFeatures: ["hit-test", "dom-overlay", "dom-overlay-for-handheld-ar"]
    },
    children,
    ...rest
  }, ref) => React3.createElement(XRButton, {
    ...rest,
    ref,
    mode: "AR",
    style,
    sessionInit
  }, children)
);
var VRButton = React3.forwardRef(
  ({
    style = buttonStyles,
    sessionInit = { optionalFeatures: ["local-floor", "bounded-floor", "hand-tracking", "layers"] },
    children,
    ...rest
  }, ref) => React3.createElement(XRButton, {
    ...rest,
    ref,
    mode: "VR",
    style,
    sessionInit
  }, children)
);
function useXR(selector = (state) => state, equalityFn) {
  const store = React3.useContext(XRContext);
  if (!store)
    throw new Error("useXR must be used within an <XR /> component!");
  return store(selector, equalityFn);
}
function useController(handedness) {
  const controllers = useXR((state) => state.controllers);
  const controller = React3.useMemo(
    () => controllers.find(({ inputSource }) => inputSource.handedness === handedness),
    [handedness, controllers]
  );
  return controller;
}

// node_modules/@react-three/xr/dist/XRControllerModelFactory.mjs
var DEFAULT_PROFILES_PATH = "https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles";
var DEFAULT_PROFILE = "generic-trigger";
var applyEnvironmentMap = (envMap, obj) => {
  obj.traverse((child) => {
    if (child instanceof Mesh && "envMap" in child.material) {
      child.material.envMap = envMap;
      child.material.needsUpdate = true;
    }
  });
};
var XRControllerModel = class extends Object3D {
  constructor() {
    super();
    this.motionController = null;
    this.envMap = null;
    this.scene = null;
  }
  setEnvironmentMap(envMap) {
    if (this.envMap == envMap) {
      return this;
    }
    this.envMap = envMap;
    applyEnvironmentMap(this.envMap, this);
    return this;
  }
  connectModel(scene) {
    if (!this.motionController) {
      console.warn("scene tried to add, but no motion controller");
      return;
    }
    this.scene = scene;
    addAssetSceneToControllerModel(this, scene);
    this.dispatchEvent({
      type: "modelconnected",
      data: scene
    });
  }
  connectMotionController(motionController) {
    this.motionController = motionController;
    this.dispatchEvent({
      type: "motionconnected",
      data: motionController
    });
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    if (!this.motionController)
      return;
    this.motionController.updateFromGamepad();
    Object.values(this.motionController.components).forEach((component) => {
      Object.values(component.visualResponses).forEach((visualResponse) => {
        const { valueNode, minNode, maxNode, value, valueNodeProperty } = visualResponse;
        if (!valueNode)
          return;
        if (valueNodeProperty === MotionControllerConstants.VisualResponseProperty.VISIBILITY && typeof value === "boolean") {
          valueNode.visible = value;
        } else if (valueNodeProperty === MotionControllerConstants.VisualResponseProperty.TRANSFORM && minNode && maxNode && typeof value === "number") {
          valueNode.quaternion.slerpQuaternions(minNode.quaternion, maxNode.quaternion, value);
          valueNode.position.lerpVectors(minNode.position, maxNode.position, value);
        }
      });
    });
  }
  disconnect() {
    this.dispatchEvent({
      type: "motiondisconnected",
      data: this.motionController
    });
    this.dispatchEvent({
      type: "modeldisconnected",
      data: this.scene
    });
    this.motionController = null;
    if (this.scene) {
      this.remove(this.scene);
    }
    this.scene = null;
  }
  dispose() {
    this.disconnect();
  }
};
function findNodes(motionController, scene) {
  Object.values(motionController.components).forEach((component) => {
    const { type, touchPointNodeName, visualResponses } = component;
    if (type === MotionControllerConstants.ComponentType.TOUCHPAD && touchPointNodeName) {
      component.touchPointNode = scene.getObjectByName(touchPointNodeName);
      if (component.touchPointNode) {
        const sphereGeometry = new SphereGeometry(1e-3);
        const material = new MeshBasicMaterial({ color: 255 });
        const sphere = new Mesh(sphereGeometry, material);
        component.touchPointNode.add(sphere);
      } else {
        console.warn(`Could not find touch dot, ${component.touchPointNodeName}, in touchpad component ${component.id}`);
      }
    }
    Object.values(visualResponses).forEach((visualResponse) => {
      const { valueNodeName, minNodeName, maxNodeName, valueNodeProperty } = visualResponse;
      if (valueNodeProperty === MotionControllerConstants.VisualResponseProperty.TRANSFORM && minNodeName && maxNodeName) {
        visualResponse.minNode = scene.getObjectByName(minNodeName);
        visualResponse.maxNode = scene.getObjectByName(maxNodeName);
        if (!visualResponse.minNode) {
          console.warn(`Could not find ${minNodeName} in the model`);
          return;
        }
        if (!visualResponse.maxNode) {
          console.warn(`Could not find ${maxNodeName} in the model`);
          return;
        }
      }
      visualResponse.valueNode = scene.getObjectByName(valueNodeName);
      if (!visualResponse.valueNode) {
        console.warn(`Could not find ${valueNodeName} in the model`);
      }
    });
  });
}
function addAssetSceneToControllerModel(controllerModel, scene) {
  findNodes(controllerModel.motionController, scene);
  if (controllerModel.envMap) {
    applyEnvironmentMap(controllerModel.envMap, scene);
  }
  controllerModel.add(scene);
}
var XRControllerModelFactory = class {
  constructor(gltfLoader = null, path = DEFAULT_PROFILES_PATH) {
    this.gltfLoader = gltfLoader != null ? gltfLoader : new GLTFLoader();
    this.path = path;
    this._assetCache = {};
  }
  initializeControllerModel(controllerModel, event) {
    const xrInputSource = event.data;
    if (xrInputSource.targetRayMode !== "tracked-pointer" || !xrInputSource.gamepad)
      return;
    fetchProfile(xrInputSource, this.path, DEFAULT_PROFILE).then(({ profile, assetPath }) => {
      if (!assetPath) {
        throw new Error("no asset path");
      }
      const motionController = new MotionController(xrInputSource, profile, assetPath);
      controllerModel.connectMotionController(motionController);
      const assetUrl = motionController.assetUrl;
      const cachedAsset = this._assetCache[assetUrl];
      if (cachedAsset) {
        const scene = cachedAsset.scene.clone();
        controllerModel.connectModel(scene);
      } else {
        if (!this.gltfLoader) {
          throw new Error("GLTFLoader not set.");
        }
        this.gltfLoader.setPath("");
        this.gltfLoader.load(
          assetUrl,
          (asset) => {
            if (!controllerModel.motionController) {
              console.warn("motionController gone while gltf load, bailing...");
              return;
            }
            this._assetCache[assetUrl] = asset;
            const scene = asset.scene.clone();
            controllerModel.connectModel(scene);
          },
          void 0,
          () => {
            throw new Error(`Asset ${assetUrl} missing or malformed.`);
          }
        );
      }
    }).catch((err) => {
      console.warn(err);
    });
  }
};

// node_modules/@react-three/xr/dist/Controllers.mjs
var Ray = React4.forwardRef(function Ray2({ target, hideOnBlur = false, ...props }, forwardedRef) {
  const hoverState = useXR((state) => state.hoverState);
  const ray = React4.useRef(null);
  const rayGeometry = React4.useMemo(
    () => new BufferGeometry().setFromPoints([new Vector3(0, 0, 0), new Vector3(0, 0, -1)]),
    []
  );
  React4.useImperativeHandle(forwardedRef, () => ray.current);
  useFrame(() => {
    let rayLength = 1;
    const intersection = hoverState[target.inputSource.handedness].values().next().value;
    if (intersection && target.inputSource.handedness !== "none") {
      rayLength = intersection.distance;
      if (hideOnBlur)
        ray.current.visible = false;
    } else if (hideOnBlur) {
      ray.current.visible = true;
    }
    const offset = -0.01;
    ray.current.scale.z = rayLength + offset;
  });
  return React4.createElement("line", {
    ref: ray,
    geometry: rayGeometry,
    "material-opacity": 0.8,
    "material-transparent": true,
    ...props
  });
});
var modelFactory = new XRControllerModelFactory();
var ControllerModel = class extends Group {
  constructor(target) {
    super();
    this.xrControllerModel = new XRControllerModel();
    this.target = target;
    this.add(this.xrControllerModel);
    this._onConnected = this._onConnected.bind(this);
    this._onDisconnected = this._onDisconnected.bind(this);
    this.target.controller.addEventListener("connected", this._onConnected);
    this.target.controller.addEventListener("disconnected", this._onDisconnected);
  }
  _onConnected(event) {
    modelFactory.initializeControllerModel(this.xrControllerModel, event);
  }
  _onDisconnected(_event) {
    this.xrControllerModel.disconnect();
  }
  dispose() {
    this.target.controller.removeEventListener("connected", this._onConnected);
    this.target.controller.removeEventListener("disconnected", this._onDisconnected);
  }
};
function Controllers({ rayMaterial = {}, hideRaysOnBlur = false }) {
  const controllers = useXR((state) => state.controllers);
  const isHandTracking = useXR((state) => state.isHandTracking);
  const rayMaterialProps = React4.useMemo(
    () => Object.entries(rayMaterial).reduce(
      (acc, [key, value]) => ({
        ...acc,
        [`material-${key}`]: value
      }),
      {}
    ),
    [JSON.stringify(rayMaterial)]
  );
  React4.useMemo(() => extend({ ControllerModel }), []);
  useIsomorphicLayoutEffect(() => {
    for (const target of controllers) {
      target.controller.dispatchEvent({ type: "connected", data: target.inputSource, fake: true });
    }
  }, [controllers]);
  return React4.createElement(React4.Fragment, null, controllers.map((target, i) => React4.createElement(React4.Fragment, {
    key: i
  }, createPortal(React4.createElement("controllerModel", {
    args: [target]
  }), target.grip), createPortal(
    React4.createElement(Ray, {
      visible: !isHandTracking,
      hideOnBlur: hideRaysOnBlur,
      target,
      ...rayMaterialProps
    }),
    target.controller
  ))));
}

// node_modules/@react-three/xr/dist/Hands.mjs
var React5 = __toESM(require_react(), 1);
function Hands({ modelLeft, modelRight }) {
  const controllers = useXR((state) => state.controllers);
  React5.useMemo(() => extend({ OculusHandModel }), []);
  useIsomorphicLayoutEffect(() => {
    for (const target of controllers) {
      target.hand.dispatchEvent({ type: "connected", data: target.inputSource, fake: true });
    }
  }, [controllers, modelLeft, modelRight]);
  return React5.createElement(React5.Fragment, null, controllers.map(({ hand }) => createPortal(React5.createElement("oculusHandModel", {
    args: [hand, modelLeft, modelRight]
  }), hand)));
}
export {
  ARButton,
  Controllers,
  Hands,
  InteractionManager,
  Interactive,
  Ray,
  RayGrab,
  VRButton,
  XR,
  XRButton,
  XRController,
  startSession,
  stopSession,
  toggleSession,
  useController,
  useHitTest,
  useInteraction,
  useXR,
  useXREvent
};
//# sourceMappingURL=@react-three_xr.js.map
